"""
Functions for masking AF3 MSA with pocket residues and removing duplicates.

This module provides functions to apply pocket masks to both unpaired and paired MSAs
generated by AlphaFold3, with support for handling sequence alignment mismatches.
"""

def apply_pocket_mask_to_msa(msa_string, pocket_mask, verbose=False):
    """
    Apply pocket mask to AF3 MSA sequences (works for both unpaired and paired MSAs).
    The first sequence (query sequence) is kept unchanged.
    Only subsequent sequences are masked and deduplicated.
    Handles sequence alignment mismatches by truncating/padding sequences as needed.
    
    Args:
        msa_string: AF3 MSA string in FASTA format (unpaired or paired)
        pocket_mask: List or array of 0s and 1s indicating pocket residues
        verbose: Whether to print verbose output
        
    Returns:
        str: Masked MSA string with first sequence unchanged and duplicates removed
    """
    if not msa_string or not pocket_mask:
        return msa_string
        
    lines = msa_string.strip().split('\n')
    result_sequences = []
    seen_sequences = set()
    
    sequence_length = len(pocket_mask)
    sequence_count = 0
    
    i = 0
    while i < len(lines):
        line = lines[i].strip()
        if line.startswith('>'):
            # Header line
            if i + 1 < len(lines):
                seq_line = lines[i + 1].strip()
                
                if sequence_count == 0:
                    # First sequence (query sequence) - keep unchanged
                    result_sequences.append(line)  # header
                    result_sequences.append(seq_line)  # original sequence
                    seen_sequences.add(seq_line)  # add to seen to avoid duplication
                    if verbose:
                        print(f"Keeping first sequence (query) unchanged: {seq_line[:50]}...")
                else:
                    # Subsequent sequences - apply mask (handles length mismatches)
                    masked_seq = apply_mask_to_sequence(seq_line, pocket_mask)
                    
                    # Check if we've seen this masked sequence before
                    if masked_seq not in seen_sequences:
                        seen_sequences.add(masked_seq)
                        result_sequences.append(line)  # header
                        result_sequences.append(masked_seq)  # masked sequence
                
                sequence_count += 1
                i += 2  # Skip both header and sequence line
            else:
                i += 1
        else:
            i += 1
    
    result = '\n'.join(result_sequences)
    
    if verbose:
        original_count = msa_string.count('>')
        final_count = result.count('>')
        print(f"Pocket masked MSA: {original_count} -> {final_count} sequences (first sequence kept unchanged, others masked and deduplicated)")
    
    return result

def apply_mask_to_sequence(sequence, mask):
    """
    Apply mask to a single sequence, handling alignment gaps.
    
    Args:
        sequence: Amino acid sequence string (may contain gaps)
        mask: List or array of 0s and 1s for the reference sequence
        
    Returns:
        str: Masked sequence where non-pocket positions are replaced with '-'
    """
    if len(sequence) != len(mask):
        # Handle alignment: map the sequence to reference positions
        return apply_mask_to_aligned_sequence(sequence, mask)
    
    masked_chars = []
    for char, mask_val in zip(sequence, mask):
        if mask_val == 1:
            masked_chars.append(char)
        else:
            masked_chars.append('-')
    
    return ''.join(masked_chars)

def apply_mask_to_aligned_sequence(sequence, mask):
    """
    Apply mask to an aligned sequence that may have insertions/deletions.
    
    Args:
        sequence: Aligned amino acid sequence (may be longer/shorter than mask)
        mask: List or array of 0s and 1s for the reference sequence
        
    Returns:
        str: Masked sequence where non-pocket positions are replaced with '-'
    """
    # Simple strategy: if sequence is longer, truncate extra characters
    # If sequence is shorter, pad with gaps
    
    if len(sequence) == len(mask):
        # Perfect match, apply mask directly
        return ''.join(char if mask_val == 1 else '-' for char, mask_val in zip(sequence, mask))
    elif len(sequence) > len(mask):
        # Sequence is longer, truncate to mask length
        truncated_seq = sequence[:len(mask)]
        return ''.join(char if mask_val == 1 else '-' for char, mask_val in zip(truncated_seq, mask))
    else:
        # Sequence is shorter, pad with gaps and apply mask
        padded_seq = sequence + '-' * (len(mask) - len(sequence))
        return ''.join(char if mask_val == 1 else '-' for char, mask_val in zip(padded_seq, mask))

def remove_duplicate_msa_sequences(msa_string, verbose=False):
    """
    Remove duplicate sequences from MSA string.
    
    Args:
        msa_string: MSA string in FASTA format
        verbose: Whether to print verbose output
        
    Returns:
        str: MSA string with duplicates removed
    """
    if not msa_string:
        return msa_string
        
    lines = msa_string.strip().split('\n')
    unique_sequences = []
    seen_sequences = set()
    
    i = 0
    while i < len(lines):
        line = lines[i].strip()
        if line.startswith('>'):
            # Header line
            if i + 1 < len(lines):
                seq_line = lines[i + 1].strip()
                if seq_line not in seen_sequences:
                    seen_sequences.add(seq_line)
                    unique_sequences.append(line)  # header
                    unique_sequences.append(seq_line)  # sequence
                i += 2  # Skip both header and sequence line
            else:
                i += 1
        else:
            i += 1
    
    result = '\n'.join(unique_sequences)
    
    if verbose:
        original_count = msa_string.count('>')
        final_count = result.count('>')
        print(f"MSA deduplication: {original_count} -> {final_count} unique sequences")
    
    return result
